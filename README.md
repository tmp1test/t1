# Описание

## Настройка базы данных

Заходим в mysql под root (или другим пользователем, у которого есть соответствующие права) и выполняем следующую последовательность действий.
Названия базы, юзер и пароль даны для примера. В случае их изменения нужно будет внести соответствующие правки в конфиг (п.1)

Создаем базу данных 1test:\
`CREATE DATABASE 1test;`

Создаем пользователя 1test:\
`CREATE USER '1test'@'localhost' IDENTIFIED BY '1test';`

Даем ему права на базу 1test:\
`GRANT ALL PRIVILEGES ON 1test.* TO '1test'@'localhost';`

Применяем права:\
`FLUSH PRIVILEGES;`

## Настройка конфига

В директории config/ есть пример конфига config.json.example, чтобы напрямую в гите не хранить авторизационные данные к базе данным, другим хранилищам или сторонним API.

Если вы использовали дефолтные команды из п.0, то нам достаточно просто скопировать файл config.json.example и переименовать его копию в config.json
Если нет, тогда нужно внести соответствующие изменения в файл config.json

## Установка зависимостей

Для того, чтобы установить зависимости, в директории проекта выполните команду:\
`npm i`

## Загрузка дампа базы данных

Для облегчения тестирования в репозитории имеется некое подобие командного интерфейса (cli.js)

Чтобы загрузить данные в базу данных достаточно ввести в терминале в папке проекта\
`node cli sql quick`

Также есть отдельные команды:

удаление таблиц\
`node cli sql drop`

создание таблиц\
`node cli sql sync`

вставка данных\
`node cli sql seed <books_count> <authors_count>`

Команда расположены в директории commands

## Тестирование проекта

Для тестирования проекта нужно в терминале запустить веб-сервер с помощью команды\
`npm start`

После этого в другой вкладке терминала\
`npm test`

Обращаю внимание на 2 момента:\
-Один из тестов проверяет "устаривание" кеша. При дефолтных настройках это длится около 5сек.\
-При тестировании содержимое таблиц с данными очищается (Тесты естественно не должны запускаться на продакшн базе). После тестирования можно воспользоваться командой sql seed для вставки данных, если это необходимо.\

Также API можно протестировать и в ручном режиме. Например, через curl для дефолтной конфигурации:\
`curl -X GET 'http://localhost:3000/books?limit=100&offset=0&order=title'`

## О задании

Проект занял около 8-9ч моего времени, из которых чуть больше половины пришлась на обучение и комментирование проекта. В ходе работы познакомился с фреймворком koa2, а также освежил знания по MySQL (работаю в основном с PostgreSQL)

В проекте есть две таблицы: authors и books. Books связана с authors с помощью внешнего ключа author_id. Точного требования к структуре таблиц не было, поэтому я ограничился одним автором на одну книгу. На каждый столбец, который может использоваться в сортировке, создан индекс. 
В задании также было фраза про группировку, но у книг нет никаких "статистических" данных (например, просмотры, скачивания и т.д.). Группировку используют обычно для разбития какой-то статистики. Возможно имелась в виду фильтрация данных, что собственно я и сделал.
Также во всех таблицах добавлены служебные поля: created_at и updated_at. Они не используются в API, но могут быть полезны для разбора каких-то внутренних ситуаций.

Все запросы выполнены на чистом SQL с использованием модуля mysql2.
Запросы проанализированы с помощью EXPLAIN в консоли mysql, все используют индексы. Единственный вопрос, который остался не решенным - это сортировка без дополнительных условий по полю description (описание). Само поле сделано текстовым, построение частичного индекса по колонке не помогает, я все равно вижу, что идет практически полный перебор таблицы. На практике такой кейс считаю не использующимся, поэтому не стал уделять этому вопросу больше времени или же хитрить и делать поле varchar(255), например.

Также в задании было сказано о возможности кеширования списка книг. Поскольку не было дано никаких точных указаний по использованию я решил обойтись внутренним кешем приложения.
Чтобы не усложнять логику на данный момент кешируется каждый запрос по следующему алгоритму:
-Есть ли ключ в кеше? да - выводим
-Если нет, стучимся в базу и сохраняем результат в кеш для дальнейшего использования. Выводим ответ.

У кеша есть ttl, который можно задать в конфиге приложения. Для ускорения тестов он выставлен в 5с.

Минусы данного решения:\
-возможен "dog pile" эффект\
-кеш не масштабируется горизонтально\
Плюсы:\
-быстрая реализация (старался уложиться в поставленное время), которая подходит для тестового приложения.\
-быстродействие\

В продакшне обычно кеширую в редисе или мемкеше.

## Структура проекта

app.js - основной файл приложения\
cli.js - "командный" интерфейс\
commands/ - команды\
config/ - конфигурация приложения\
controllers/ - контроллеры\
models/ - модели для взаимодействия с базой данных\
routes/ - роутинг\
services/ - сервисы (пул коннектов к базе данных, кеш и др.)\
tests/ - юнит и интеграционные тесты (для работы интеграционных тестов должен быть запущен инстанс приложения)
